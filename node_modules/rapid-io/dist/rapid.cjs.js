
 /*
  * rapid-io v0.4.2
  * (c) 2017 Pavel Prichodko
  * https://github.com/rapid-io/javascript
  * released under the MIT License
  */

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var base64 = _interopDefault(require('base-64'));
var EventEmitter = _interopDefault(require('component-emitter'));
var shortid = _interopDefault(require('shortid'));
var debug = _interopDefault(require('debug'));
var sortKeys = _interopDefault(require('sort-keys'));
var Backoff = _interopDefault(require('backo'));
var _rapidIo_protocol = require('@rapid-io/protocol');
var NodeWebSocket = _interopDefault(require('ws'));

const BrowserWebSocket = global.WebSocket;

const logger$2 = debug('rapid:ws');

class WebSocket extends EventEmitter {
  constructor(url, opts = {}) {
    super();
    this.url = url;
    this.perMessageDeflate = opts.perMessageDeflate || false;
    this.protocols = opts.protocols || null;
    this.isUsingBrowserWebSocket = Boolean(BrowserWebSocket);
    this.open();
  }

  open() {
    const url = this.url,
          protocols = this.protocols,
          isUsingBrowserWebSocket = this.isUsingBrowserWebSocket;

    const wsUrl = `wss://${url}`;

    const opts = {
      perMessageDeflate: this.perMessageDeflate
      // more node specific options like SSL etc
    };

    try {
      if (isUsingBrowserWebSocket) {
        this.ws = new BrowserWebSocket(wsUrl);
      } else {
        this.ws = new NodeWebSocket(wsUrl, protocols, opts);
      }
    } catch (err) {
      this.emit('error', err);
    }

    this.addEventListeners();
  }

  addEventListeners() {
    this.ws.onopen = () => this.emit('open');
    this.ws.onmessage = event => this.emit('message', event.data);
    this.ws.onclose = () => this.emit('close');
    this.ws.onerror = err => this.emit('error', err);
  }

  send(message) {
    if (this.ws.readyState !== this.ws.OPEN) {
      throw new Error('WebSocket is not open');
    }

    try {
      this.ws.send(JSON.stringify(message));
    } catch (error) {
      logger$2('WebSocket was not able to send data, becase it has been already closed.');
    }
  }

  close() {
    if (typeof this.ws !== 'undefined' && (this.ws.readyState === this.ws.CONNECTING || this.readyState === this.ws.OPEN)) {
      this.ws.close();
    }
  }

  get CONNECTING() {
    return 0;
  }
  get OPEN() {
    return 1;
  }
  get CLOSING() {
    return 2;
  }
  get CLOSED() {
    return 3;
  }
  get readyState() {
    return this.ws.readyState;
  }
}

/**
 * Event listener helper
 * @param {EventEmitter} emitter source
 * @param {String} event listen
 * @param {Function} fn callback
 * @return {object} object with a 'off' method to remove listener
 */

var on = ((emitter, event, fn) => {
  emitter.on(event, fn);
  return {
    off: () => emitter.off(event, fn)
  };
});

var jsonparse = (val => {
  try {
    return JSON.parse(val);
  } catch (error) {
    return null;
  }
});

var jsonprune = (obj => {
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (err) {
    console.log(err);
    return null;
  }
});

const logger$1 = debug('rapid:transport');

class Transport extends EventEmitter {
  constructor(url, {
    reconnectDelay = 1000,
    reconnectDelayMax = 5000,
    reconnectAttempts = Infinity
  } = {}) {
    super();
    this.url = url;
    this.reconnectAttempts = reconnectAttempts;
    this.backoff = new Backoff({ min: reconnectDelay, max: reconnectDelayMax });
    this.readyState = 'closed';
    this.subs = [];
    this.reconnecting = false;
    this.skipReconnect = false;
    this.connect();
  }

  open(onopen, onerror) {
    if (this.readyState === 'open') {
      return;
    }

    this.cleanup();

    logger$1('opening %s', this.url);
    this.ws = new WebSocket(this.url);
    this.readyState = 'opening';
    this.skipReconnect = false;
    const opensub = on(this.ws, 'open', () => {
      this.readyState = 'open';
      onopen();
    });
    const errsub = on(this.ws, 'error', err => {
      this.readyState = 'closed';
      onerror(err);
    });
    const closeSub = on(this.ws, 'close', () => this.onclose());

    this.subs.push(opensub, errsub, closeSub);
  }

  send(message) {
    message = jsonprune(message);
    const valid = _rapidIo_protocol.validate.message(message);
    if (!valid) {
      logger$1('trying to send invalid message: %O', message);
      throw new Error('Invalid message format sending to a server');
    }

    if (this.readyState === 'open') {
      this.ws.send(message);
    } else {
      logger$1('cannot send message, websocket is not open - %o', message);
    }
  }

  connect() {
    this.open(() => this.onconnect(), err => {
      logger$1('initial connect error %o', err.message);
      if (!this.reconnecting && this.backoff.attempts === 0) {
        this.reconnect();
      }
    });
  }

  reconnect() {
    const delay = this.backoff.duration();
    logger$1('reconnect attempt in %d', delay);
    this.reconnecting = true;
    const timeout = setTimeout(() => {
      logger$1('attempting to reconnect');
      this.open(() => this.onreconnect(), err => {
        logger$1('reconnect unsuccessful, %o', err.message);
        this.reconnecting = false;
        this.reconnect();
      });
    }, delay);

    this.subs.push({ off: () => clearTimeout(timeout) });
  }

  onconnect() {
    logger$1('websocket opened');
    this.subs.push(on(this.ws, 'message', msg => this.onmessage(msg)), on(this.ws, 'error', err => this.onerror(err)));
    this.emit('connected', true);
    this.emit('connect');
  }

  onreconnect() {
    const attempts = this.backoff.attempts;

    logger$1('reconnect successful after %d attempts', attempts);
    this.reconnecting = false;
    this.backoff.reset();
    this.emit('reconnect');
    this.subs.push(on(this.ws, 'message', msg => this.onmessage(msg)), on(this.ws, 'close', () => this.onclose()), on(this.ws, 'error', err => this.onerror(err)));
  }

  onclose() {
    logger$1('websocket closed');
    this.readyState = 'closed';
    this.emit('connected', false);
    this.backoff.reset();
    this.cleanup();
    if (!this.skipReconnect) {
      this.reconnect();
    }
  }

  onerror(err) {
    logger$1('websocket error %o', err);
    this.ws.close();
  }

  onmessage(msg) {
    const parsed = jsonparse(msg);
    if (parsed === null) {
      logger$1('message is not in JSON format');
    } else {
      this.emit('event', parsed);
    }
  }

  disconnect() {
    logger$1('disconnecting');
    this.skipReconnect = true;
    this.reconnecting = true;
    if (this.readyState === 'opening') {
      this.cleanup();
    }
    this.backoff.reset();
    this.readyState = 'closed';
    if (this.ws) {
      this.ws.close();
    }
  }

  cleanup() {
    this.subs.forEach(sub => sub.off());
  }
}

/**
 * Remove listeners helper
 * @param {Array} listeners array of unsubscribe functions
 * @return {Object} off function to remove listeners
 */

var listen = (listeners => ({
  off() {
    listeners.forEach(listener => listener.off());
  }
}));

// import debug from 'debug'
// const log = debug('rapid:subscription')

class Subscription {
  constructor({ io, query = {}, onVal, onErr }) {
    this.io = io;
    this.id = shortid.generate();
    this.query = query;
    this.listeners = null;
    this.valueListeners = [onVal];
    this.errorListeners = onErr ? [onErr] : [];
    this.docs = [];
    this.subscribed = false;
    this.unsubscribed = false;
    this.changes = {
      added: [],
      updated: [],
      removed: []
    };
    this.subscribe();
  }

  subscribe() {
    this.listeners = listen([on(this.io, 'val', val => this.onvalue(val)), on(this.io, 'upd', upd => this.onupdate(upd)), on(this.io, 'batch', batch => this.onbatch(batch)), on(this.io, 'rm', rm => this.onremove(rm))]);
  }

  onbatch(batch) {
    let shouldNotify = false;
    batch.forEach(evt => {
      if (evt.val) {
        shouldNotify = true;
        return this.onvalue(evt.val, { batch: true });
      }
      if (evt.upd) {
        shouldNotify = true;
        return this.onupdate(evt.upd, { batch: true });
      }
      if (evt.rm) {
        shouldNotify = true;
        return this.onremove(evt.rm, { batch: true });
      }
    });
    shouldNotify && this.notify();
  }

  onvalue(value, { batch = false } = {}) {
    if (value['sub-id'] === this.id) {
      this.acknowledge(value);
      this.docs = value.docs;
      this.changes.added.push(...this.docs);
      !batch && this.notify();
    }
  }

  onupdate(update, { batch = false } = {}) {
    if (update['sub-id'] === this.id) {
      this.acknowledge(update);

      const docIdx = this.docs.findIndex(doc => doc.id === update.doc.id);

      if (docIdx !== -1) {
        this.docs[docIdx] = update.doc;
        this.changes.updated.push(update.doc);
      } else {
        this.docs.push(update.doc);
        this.changes.added.push(update.doc);
      }
      this.sort();
      this.checkLimit();
      !batch && this.notify();
    }
  }

  onremove(remove, { batch = false } = {}) {
    if (remove['sub-id'] === this.id) {
      this.acknowledge(remove);

      const docIdx = this.docs.findIndex(doc => doc.id === remove.doc.id);

      if (docIdx !== -1) {
        const removedDoc = this.docs.splice(docIdx, 1);
        this.changes.removed.push(...removedDoc);
        !batch && this.notify();
      }
    }
  }

  sort() {
    this.docs.sort((current, next) => {
      // eslint-disable-next-line guard-for-in
      for (const idx in current.skey) {
        const currentSortkey = current.skey[idx];
        const nextSortkey = next.skey[idx];

        if (currentSortkey === nextSortkey) {
          continue;
        }

        const order = this.query.order;

        const ordering = order[Object.keys(order)[0]];
        // const orderObj = this.query.order[idx]
        // const ordering = orderObj[Object.keys(orderObj)[0]] // get value of first object key

        if (ordering === 'asc') {
          return currentSortkey < nextSortkey ? -1 : 1;
        }
        return currentSortkey < nextSortkey ? 1 : -1;
      }

      const orderObj = this.query.order && this.query.order[0];
      const ordering = orderObj ? orderObj[Object.keys(orderObj)[0]] : 'asc';

      if (ordering === 'asc') {
        return current.crt < next.crt ? -1 : 1;
      }
      return current.crt < next.crt ? 1 : -1;
    });
  }

  checkLimit() {
    const docs = this.docs;
    var _query$limit = this.query.limit;
    const limit = _query$limit === undefined ? null : _query$limit;


    if (limit && docs.length > limit) {
      const overflow = docs.length - limit;
      docs.splice(-overflow, overflow);
    }
  }

  acknowledge(evt) {
    this.io.acknowledge(evt['evt-id']);
  }

  notify() {
    if (!this.unsubscribed) {
      this.valueListeners.forEach(onVal => {
        onVal(this.docs, this.changes);
      });
      this.changes = {
        added: [],
        updated: [],
        removed: []
      };
    }
  }

  addListeners(onVal, onErr) {
    onVal && this.valueListeners.push(onVal);
    onErr && this.errorListeners.push(onErr);
  }

  unsubscribe(onVal, onErr) {
    if (onVal) {
      this.valueListeners = this.valueListeners.filter(fn => fn !== onVal);
    }
    if (onErr) {
      this.errorListeners = this.errorListeners.filter(fn => fn !== onErr);
    }

    if (isEmpty(this.valueListeners) && isEmpty(this.errorListeners)) {
      this.unsubscribed = true;
      this.listeners.off();
    }
  }

  cancel(err) {
    this.errorListeners.forEach(onErr => onErr(err));
    this.listeners.off();
    this.valueListeners = [];
    this.errorListeners = [];
  }

  set evt(evt) {
    this._evt = evt;
  }

  get evt() {
    return this._evt;
  }
}

function isEmpty(arr) {
  return arr.length === 0;
}

/**
 * Creates an acknowledgement event
 * @param {string} evtId event id
 * @return {Object} event
 */

const ack = evtId => ({
  ack: {
    'evt-id': evtId
  }
});

/**
 * Creates a connect protocol event
 * @return {Object} event
 */

const con = conId => ({
  con: {
    'evt-id': shortid.generate(),
    'con-id': conId
  }
});

/**
 * Creates a reconnect protocol event
 * @param {string} conId connection id
 * @return {Object} event
 */

const rec = conId => ({
  rec: {
    'evt-id': shortid.generate(),
    'con-id': conId
  }
});

/**
 * Creates a disconnect protocol event
 * @return {Object} event
 */

/**
 *
 * @param {string} colId collection ID
 * @param {string} docId document ID
 * @param {object} body properties to mutate
 * @return {Object} event
 */

const mut = (colId, docId, body, etag) => ({
  mut: {
    'evt-id': shortid.generate(),
    'col-id': colId,
    doc: {
      id: docId,
      etag,
      body
    }
  }
});

/**
 * Creates a merge protocol event
 * @param {string} colId collection id
 * @param {string} docId documend id
 * @param {object} body properties to merge
 * @return {Object} event
 */

const mer = (colId, docId, body, etag) => ({
  mer: {
    'evt-id': shortid.generate(),
    'col-id': colId,
    doc: {
      id: docId,
      etag,
      body
    }
  }
});

/**
 * Creates a delete protocol event
 * @param {string} colId collection id
 * @param {string} docId documend id
 * @return {Object} event
 */

const del = (colId, docId, etag) => ({
  del: {
    'evt-id': shortid.generate(),
    'col-id': colId,
    doc: {
      id: docId,
      etag
    }
  }
});

/**
 * Creates a fetch protocol event
 * @param {string} ftc fetch id
 * @param {string} colId collection id
 * @param {object=} query query object
 * @return {Object} event
 */

const ftc = (colId, { filter, order, limit, skip }) => ({
  ftc: {
    'evt-id': shortid.generate(),
    'ftc-id': shortid.generate(),
    'col-id': colId,
    filter,
    order: order && [order],
    limit,
    skip
  }
});

/**
 * Creates a subscription protocol event
 * @param {string} subId subscription id
 * @param {string} colId collection id
 * @param {object=} query query object
 * @return {Object} event
 */

const sub = (subId, colId, { filter, order, limit, skip }) => ({
  sub: {
    'evt-id': shortid.generate(),
    'sub-id': subId,
    'col-id': colId,
    filter,
    order: order && [order],
    limit,
    skip
  }
});

/**
 * Creates an unsubscribe protocl event
 * @param {string} subId subscription id
 * @return {Object} event
 */

const uns = subId => ({
  uns: {
    'evt-id': shortid.generate(),
    'sub-id': subId
  }
});

/**
 * Creates an autharization protocol event
 * @param {string} authToken authorization token
 * @return {Object} event
 */

const auth = authToken => ({
  auth: {
    'evt-id': shortid.generate(),
    token: authToken
  }
});

/**
 * Creates an deauthorization protocol event
 * @return {Object} event
 */

const deauth = () => ({
  deauth: {
    'evt-id': shortid.generate()
  }
});

/**
 * Create channel subscription event
 * @param {(String|Object)} chanId channel id
 * @param {String} subId subscription id
 * @returns {Object}
 */
const subCh = ({ chanId, subId }) => ({
  'sub-ch': {
    'evt-id': shortid(),
    'chan-id': chanId,
    'sub-id': subId
  }
});

/**
 * Create channel unsubscription event
 * @param {String} subId subscription id
 * @returns {Object}
 */
const unsCh = ({ subId }) => ({
  'uns-ch': {
    'evt-id': shortid(),
    'sub-id': subId
  }
});

/**
 * Creates publish event
 * @param {(String|Object)} chanId channel id
 * @param {Object} body channel message
 * @returns {Object}
 */
const pub = ({ chanId, body }) => ({
  pub: {
    'evt-id': shortid(),
    'chan-id': chanId,
    body
  }
});

/**
 * No operation event
 * @return {Object} event
 */

const nop = () => ({
  nop: null
});

/*
 * Protocol events
 */

function isEmpty$1(array) {
  return array.length === 0;
}

class Channel {
  constructor({ subId, chanId, connection, remove }) {
    this.chanId = chanId;
    this.subId = subId;
    this.connection = connection;
    this.remove = remove;
    this.valueListeners = [];
    this.errorListeners = [];
    this.buffer = new Map();
    this.subscribed = false;
    this.unsubscribed = false;
    this.connect();
  }

  connect() {
    if (this.unsubscribed) {
      this.unsubscribe();
      return;
    }

    if (!this.subscribed) {
      const chanId = this.chanId,
            subId = this.subId;

      this.evt = subCh({ chanId, subId });
      this.connection.send(this.evt);
    }

    this.buffer.forEach(message => {
      this.connection.send(message.evt);
    });
  }

  unsubscribe() {
    this.unsubscribed = true;
    this.evt = unsCh({ subId: this.subId });
    this.connection.send(this.evt);
  }

  subscribe(onvalue, onerror) {
    onvalue && this.valueListeners.push(onvalue);
    onerror && this.errorListeners.push(onerror);

    return () => {
      this.valueListeners = this.valueListeners.filter(fn => fn !== onvalue);
      if (isEmpty$1(this.valueListeners)) {
        this.unsubscribe();
        return;
      }
      this.errorListeners = this.errorListeners.filter(fn => fn !== onerror);
    };
  }

  publish(message) {
    return new Promise((resolve, reject) => {
      const evt = pub({ chanId: this.chanId, body: message });
      const evtId = evt.pub['evt-id'];
      this.buffer.set(evtId, { evt, resolve, reject });
      this.connection.send(evt);
    });
  }

  onack(ack) {
    const evtId = ack['evt-id'];
    if (this.unsubscribed) {
      const unsEvt = this.evt['uns-ch'];
      if (evtId === unsEvt['evt-id']) {
        this.remove();
        return;
      }
    }

    if (!this.subscribed) {
      const subEvt = this.evt['sub-ch'];
      if (evtId === subEvt['evt-id']) {
        this.subscribed = true;
        return;
      }
    }
    const message = this.buffer.get(evtId);
    if (message) {
      message.resolve();
      this.buffer.delete(evtId);
    }
  }

  onerror(err) {
    const evtId = err['evt-id'];
    const subEvt = this.evt['sub-ch'];

    if (evtId === subEvt['evt-id']) {
      this.subscribed = false;
      this.cancel(err); // TODO
      return;
    }

    const message = this.buffer.get(evtId);
    if (message) {
      message.reject(err);
      this.buffer.delete(evtId);
    }
  }

  message(mes) {
    if (!this.unsubscribed) {
      this.valueListeners.forEach(cb => cb(mes.body));
    }
  }

  cancel(err) {
    this.errorListeners.forEach(cb => cb(err));
  }
}

class Channels {
  constructor(connection) {
    this.connection = connection;
    this.channels = new Map();
    this.connection.on('mes', mes => this.onmessage(mes));
    this.connection.on('ca-ch', ca => this.oncancel(ca));
    this.connection.on('ack', ack => this.onack(ack));
    this.connection.on('err', err => this.onerror(err));
  }

  find(chanId) {
    for (var _iterator = this.channels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      const _ref = _ref2;
      const channel = _ref[1];

      if (channel.chanId === chanId) {
        return channel;
      }
    }
    return null;
  }

  create(chanId) {
    const subId = shortid();
    const channel = new Channel({
      chanId,
      subId,
      connection: this.connection,
      remove: () => this.remove(chanId)
    });
    this.channels.set(subId, channel);
    return channel;
  }

  get(chanId) {
    const channel = this.find(chanId) || this.create(chanId);
    return channel;
  }

  subscribe(chanId, onvalue, onerror) {
    const channel = this.get(chanId);
    return channel.subscribe(onvalue, onerror);
  }

  publish(chanId, message) {
    const channel = this.get(chanId);
    return channel.publish(message);
  }

  remove(chanId, onvalue, onerror) {
    const channel = this.find(chanId);
    if (channel) {
      this.channels.delete(channel.subId);
      onvalue && onvalue();
      return;
    }
    onerror && onerror(new Error(`No subscriptions for channel named: ${chanId}`));
  }

  connect() {
    this.channels.forEach(channel => {
      channel.subscribed = false;
      channel.connect();
    });
  }

  reconnect() {
    this.channels.forEach(channel => channel.connect());
  }

  onack(ack) {
    this.channels.forEach(channel => channel.onack(ack));
  }

  onmessage(mes) {
    const subId = mes['sub-id'];
    const channel = this.channels.get(subId);
    if (channel) {
      channel.message(mes);
    }
  }

  oncancel(ca) {
    const subId = ca['sub-id'];
    const channel = this.channels.get(subId);
    if (channel) {
      channel.cancel(new Error('Channel terminated'));
      this.channels.delete(subId);
    }
  }

  onerror(err) {
    this.channels.forEach(channel => channel.onerror(err));
  }
}

class Fetch {
  constructor({ connection, evt, onValue, onError }) {
    this.connection = connection;
    this.evt = evt;
    this.onvalue = onValue;
    this.onerror = onError;
    this.acked = false;
    this.listener = on(this.connection, 'res', res => this.onresult(res));
  }

  onresult(res) {
    const ftcId = this.evt.ftc['ftc-id'];
    if (ftcId === res['ftc-id']) {
      this.onvalue(res.docs);
      this.connection.fetches.delete(this.evt.ftc['evt-id']);
      this.off();
    }
  }

  cancel(err) {
    this.onerror(err);
    this.off();
  }

  off() {
    this.listener.off();
  }
}

/*
 * Timer that invokes function after a period of time
 * also has a reset method
 */

class Timer {
  constructor(fn, delay) {
    this.fn = fn;
    this.delay = delay;
    this.interval = null;
    this.start();
  }

  start() {
    if (!this.interval) {
      this.interval = setInterval(this.fn, this.delay);
    }
  }

  stop() {
    clearInterval(this.interval);
    this.interval = null;
  }

  reset() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = setInterval(this.fn, this.delay);
    }
  }
}

const create = (type, message) => class extends Error {
  constructor(param) {
    super();
    this.type = type;
    if (param) {
      this.message = `${message} ${param}`;
    } else {
      this.message = message;
    }
  }
};

const TimeoutError = create('timeout', 'The request could not be completed in a given time:');

const PermissionError = create('permission-denied', 'You are trying to access a data you do not have a security permissions to.');

const SubscriptionError = create('subscription-terminated', "You don't have permissions to be subscribed to collection:");

const EtagConflictError = create('etag-conflict', 'Etag does not match when mutating a document.');

const InvalidAuthTokenError = create('invalid-auth-token', 'The authorization token is invalid.');

const InvalidIdError = create('invalid-id', 'Only alphanumeric characters, dashes and underscores are allowed. Invalid id:');

const logger = debug('rapid:connection');

class Connection extends EventEmitter {
  constructor(url, opts = {}) {
    super();
    this.transport = new Transport(url, opts);
    this.conId = shortid.generate();
    this.authEvent = null;
    this.subscriptions = new Map();
    this.channels = new Channels(this);
    this.fetches = new Map();
    this.writebuffer = new Map();
    this.nooptimer = new Timer(() => this.noop(), opts.noopDelay || 45000);
    this.connected = false;
    this.init();
  }

  init() {
    this.subs = [on(this.transport, 'event', evt => this.onevent(evt)), on(this.transport, 'connect', () => this.onconnect()), on(this.transport, 'reconnect', () => this.onreconnect()), on(this.transport, 'connected', state => this.emit('connected', state)), on(this, 'ack', evt => this.onack(evt)), on(this, 'err', evt => this.onerror(evt)), on(this, 'batch', evt => this.onbatch(evt)), on(this, 'ca', evt => this.oncancel(evt)), on(this, 'permission-denied', err => this.onpermissiondenied(err))];
  }

  close() {
    logger('close request');
    this.subs.forEach(sub => sub.off());
    this.nooptimer.stop();
    this.transport.disconnect();
  }

  onevent(evt) {
    const key = Object.keys(evt)[0];
    key !== 'val' ? logger('received event %s - %o', key, evt) : logger('received event %s', key);
    this.emit(key, evt[key]);
    this.nooptimer.reset();
  }

  onconnect() {
    logger('onconnect');
    this.send(con(this.conId));
    if (this.authEvent) {
      this.send(this.authEvent);
    }
    this.subscriptions.forEach(sub => {
      sub.subscribed = false;
      this.send(sub.evt);
    });
    this.fetches.forEach(ftc => {
      ftc.acked = false;
      this.send(ftc.evt);
    });
    this.flush();
    this.channels.connect();
    this.connected = true;
  }

  onreconnect() {
    logger('onreconnect');
    if (!this.connected) {
      this.onconnect();
      return;
    }
    this.send(rec(this.conId));
    this.subscriptions.forEach(sub => {
      if (!sub.subscribed) {
        this.send(sub.evt);
      }
    });
    this.fetches.forEach(ftc => {
      if (!ftc.acked) {
        this.send(ftc.evt);
      }
    });
    this.flush();
    this.channels.reconnect();
  }

  onack(evt) {
    const evtId = evt['evt-id'];
    const removed = this.writebuffer.delete(evtId);
    if (removed) {
      return;
    }

    for (var _iterator = this.subscriptions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      const _ref = _ref2;
      const val = _ref[1];

      if (val.evt.sub['evt-id'] === evtId) {
        val.subscribed = true;
        return;
      }
    }

    for (var _iterator2 = this.fetches, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref4 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref4 = _i2.value;
      }

      const _ref3 = _ref4;
      const val = _ref3[1];

      if (val.evt.ftc['evt-id'] === evtId) {
        val.acked = true;
        return;
      }
    }
  }

  onerror(evt) {
    switch (evt['err-type']) {
      case 'connection-terminated':
        return this.onconnect(); // reconnected, but server does not remember anything
      case 'invalid-auth-token':
        return this.emit('invalid-auth-token', evt);
      case 'permission-denied':
        return this.emit('permission-denied', evt);
      case 'etag-conflict':
        return this.emit('etag-conflict', evt);
      default:
        {
          return logger('unkown server error %o', evt);
        }
    }
  }

  onpermissiondenied(err) {
    const evtId = err['evt-id'];

    for (var _iterator3 = this.subscriptions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref6 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref6 = _i3.value;
      }

      const _ref5 = _ref6;
      const key = _ref5[0];
      const val = _ref5[1];

      if (val.evt.sub['evt-id'] === evtId) {
        val.cancel(new PermissionError());
        this.subscriptions.delete(key);
        return;
      }
    }

    for (var _iterator4 = this.fetches, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref8;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref8 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref8 = _i4.value;
      }

      const _ref7 = _ref8;
      const key = _ref7[0];
      const val = _ref7[1];

      if (val.evt.ftc['evt-id'] === evtId) {
        val.cancel(new PermissionError());
        this.fetches.delete(key);
        return;
      }
    }
  }

  oncancel(evt) {
    const evtId = evt['evt-id'];
    const subId = evt['sub-id'];

    this.acknowledge(evtId);

    for (var _iterator5 = this.subscriptions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref10;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref10 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref10 = _i5.value;
      }

      const _ref9 = _ref10;
      const key = _ref9[0];
      const val = _ref9[1];

      if (val.id === subId) {
        val.cancel(new SubscriptionError());
        this.subscriptions.delete(key);
      }
    }
  }

  onbatch(batch) {
    for (var _iterator6 = batch, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref11;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref11 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref11 = _i6.value;
      }

      const evt = _ref11;

      if (evt.ca) {
        this.oncancel(evt.ca);
      }
      if (evt.res) {
        this.emit('res', evt.res);
      }
    }
  }

  flush() {
    this.writebuffer.forEach(evt => this.send(evt));
  }

  send(evt) {
    logger('sending event: %o', jsonprune(evt));
    if (!evt.nop) {
      this.nooptimer.reset();
    }
    this.transport.send(evt);
  }

  acknowledge(evtId) {
    const evt = ack(evtId);
    this.send(evt);
  }

  noop() {
    const evt = nop();
    this.send(evt);
  }

  authorize(authToken) {
    const evt = auth(authToken);
    const evtId = evt.auth['evt-id'];
    this.authEvent = evt;
    this.send(evt);

    return evtId;
  }

  deauthorize() {
    const evt = deauth();
    const evtId = evt.deauth['evt-id'];
    this.authEvent = null;
    this.writebuffer.set(evtId, evt);
    this.send(evt);

    return evtId;
  }

  subscribe(colId, query, onVal, onErr) {
    query = jsonprune(query);

    const id = JSON.stringify(sortKeys({ colId, query }));
    let subscription;

    if (this.subscriptions.has(id)) {
      subscription = this.subscriptions.get(id);
      subscription.addListeners(onVal, onErr);
    } else {
      subscription = new Subscription({ io: this, query, onVal, onErr });
      const evt = sub(subscription.id, colId, query);
      subscription.evt = evt;
      this.subscriptions.set(id, subscription);
      this.send(evt);
    }

    return () => {
      subscription.unsubscribe(onVal, onErr);
      if (subscription.unsubscribed) {
        this.unsubscribe(subscription.id);
        this.subscriptions.delete(id);
      }
    };
  }

  unsubscribe(subId) {
    const evt = uns(subId);
    const evtId = evt['evt-id'];

    this.writebuffer.set(evtId, evt);
    this.send(evt);

    return evtId;
  }

  fetch(colId, query, onValue, onError) {
    const evt = ftc(colId, query);
    const evtId = evt.ftc['evt-id'];

    const fetch = new Fetch({ connection: this, evt, onValue, onError });
    this.fetches.set(evtId, fetch);

    this.send(evt);

    return evtId;
  }

  mutate(colId, docId, body, etag) {
    const evt = mut(colId, docId, body, etag);
    const evtId = evt.mut['evt-id'];

    this.writebuffer.set(evtId, evt);
    this.send(evt);

    return evtId;
  }

  merge(colId, docId, body, etag) {
    const evt = mer(colId, docId, body, etag);
    const evtId = evt.mer['evt-id'];

    this.writebuffer.set(evtId, evt);
    this.send(evt);

    return evtId;
  }

  delete(colId, docId, etag) {
    const evt = del(colId, docId, etag);
    const evtId = evt.del['evt-id'];

    this.writebuffer.set(evtId, evt);
    this.send(evt);

    return evtId;
  }

  subscribeChannel(chanId, onvalue, onerror) {
    return this.channels.subscribe(chanId, onvalue, onerror);
  }

  publishChannel(chanId, message) {
    return this.channels.publish(chanId, message);
  }

  removeChannel(chanId, onvalue, onerror) {
    return this.channels.remove(chanId, onvalue, onerror);
  }
}

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class Document {
  constructor(connection, id, colId) {
    this.connection = connection;
    this.id = id;
    this.colId = colId;
  }

  fetch(onvalue, onerror) {
    const query = {
      filter: {
        and: [{ $id: this.id }]
      }
    };
    const handler = (success, error) => {
      this.connection.fetch(this.colId, query, docs => success(docs[0] || null), error);
    };
    if (onvalue) {
      return handler(onvalue, onerror);
    }
    return new Promise(handler);
  }

  subscribe(onvalue, onerror) {
    const query = {
      filter: {
        and: [{ $id: this.id }]
      }
    };
    const unsubscribe = this.connection.subscribe(this.colId, query, data => Array.isArray(data) ? onvalue(data[0] || null) : onvalue(data), onerror);
    return { unsubscribe };
  }

  execute(handler, callback = function () {}) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const doc = yield _this.fetch();
      const body = handler(doc);
      if (typeof body === 'undefined') {
        return callback(null, false, null);
      }
      try {
        const etag = doc && { etag: doc.etag };
        if (body === null) {
          yield _this.delete(etag);
          return callback(null, true, null);
        }
        yield _this.mutate(body, etag);
        if (!doc) {
          const newDoc = yield _this.fetch();
          return callback(null, true, newDoc);
        }
        return callback(null, true, doc);
      } catch (err) {
        if (err.type === 'etag-conflict') {
          return _this.execute(handler, callback);
        }
        return callback(err, false, null);
      }
    })();
  }

  mutate(value, callback, opts = {}) {
    if (typeof callback === 'object') {
      opts = callback || {};
      callback = undefined; // eslint-disable-line no-undefined
    }
    const evtId = this.connection.mutate(this.colId, this.id, value, opts.etag);
    return this.handleEvent(evtId, callback, opts);
  }

  merge(value, callback, opts = {}) {
    if (typeof callback === 'object') {
      opts = callback || {};
      callback = undefined; // eslint-disable-line no-undefined
    }
    const evtId = this.connection.merge(this.colId, this.id, value, opts.etag);
    return this.handleEvent(evtId, callback, opts);
  }

  delete(callback, opts = {}) {
    if (typeof callback === 'object') {
      opts = callback || {};
      callback = undefined; // eslint-disable-line no-undefined
    }
    const evtId = this.connection.delete(this.colId, this.id, opts.etag);
    return this.handleEvent(evtId, callback, opts);
  }

  handleEvent(evtId, callback, opts = {}) {
    const handler = (onSuccess, onError) => {
      const listeners = listen([on(this.connection, 'ack', ack => {
        if (ack['evt-id'] === evtId) {
          listeners.off();
          onSuccess();
        }
      }), on(this.connection, 'permission-denied', err => {
        if (err['evt-id'] === evtId) {
          listeners.off();
          onError(new PermissionError());
        }
      }), on(this.connection, 'etag-conflict', err => {
        if (err['evt-id'] === evtId) {
          listeners.off();
          onError(new EtagConflictError());
        }
      })]);

      if (opts.timeout) {
        setTimeout(() => {
          onError(new TimeoutError(opts.timeout));
          listeners.off();
        }, opts.timeout);
      }
    };

    if (typeof callback === 'function') {
      return handler(docs => callback(null, docs), err => callback(err));
    }

    return new Promise((res, rej) => handler(res, rej));
  }
}

function checkId(id) {
  if (typeof id !== 'string') {
    throw new TypeError(`${id} is not type of string`);
  }

  const re = /^[0-9a-zA-Z_-]+$/;
  const valid = re.test(id);

  if (!valid) {
    throw new InvalidIdError(id);
  }

  return true;
}

class Collection {
  constructor(connection, id, query = {}) {
    this.connection = connection;
    this.id = id;
    this.query = query;
  }

  filter(filter) {
    if (typeof filter !== 'object') {
      throw new TypeError('Filter must be an object');
    }
    if (this.query.filter) {
      throw new Error(`Filter is already defined on a collection: ${this.id}`);
    }
    return new Collection(this.connection, this.id, Object.assign({}, this.query, { filter }));
  }

  order(order) {
    if (typeof order !== 'object') {
      throw new TypeError('Order must be an object');
    }
    if (this.query.order) {
      throw new Error(`Order is already defined on a collection: ${this.id}`);
    }
    return new Collection(this.connection, this.id, Object.assign({}, this.query, { order }));
  }

  limit(limit) {
    if (typeof limit !== 'number') {
      throw new TypeError('Limit must be a number');
    }
    if (this.query.limit) {
      throw new Error(`Limit is already defined on a collection: ${this.id}`);
    }
    return new Collection(this.connection, this.id, Object.assign({}, this.query, { limit }));
  }

  skip(skip) {
    if (typeof skip !== 'number') {
      throw new TypeError('Skip must be a number');
    }
    if (this.query.skip) {
      throw new Error(`Skip is already defined on a collection: ${this.id}`);
    }
    return new Collection(this.connection, this.id, Object.assign({}, this.query, { skip }));
  }

  fetch(onvalue, onerror) {
    const handler = (success, error) => {
      this.connection.fetch(this.id, this.query, success, error);
    };
    if (onvalue) {
      return handler(onvalue, onerror);
    }
    return new Promise(handler);
  }

  subscribe(onvalue, onerror) {
    const unsubscribe = this.connection.subscribe(this.id, this.query, onvalue, onerror);
    return { unsubscribe };
  }

  document(docId) {
    checkId(docId);
    return new Document(this.connection, docId, this.id);
  }

  newDocument() {
    const docId = shortid.generate();
    return new Document(this.connection, docId, this.id);
  }
}

class Channel$1 {
  constructor(connection, id) {
    this.connection = connection;
    this.id = id;
  }

  subscribe(onvalue, onerror) {
    const unsubscribe = this.connection.subscribeChannel(this.id, onvalue, onerror);
    return { unsubscribe };
  }

  publish(message, callback) {
    const p = this.connection.publishChannel(this.id, message);
    if (!callback) {
      return p;
    }
    return p.then(callback, callback);
  }

  unsubscribeAll(callback) {
    const handler = (onsuccess, onerror) => this.connection.removeChannel(this.id, onsuccess, onerror);

    if (callback) {
      return handler(callback, callback);
    }
    return new Promise(handler);
  }
}

/**
 * Event listener helper
 * @param {EventEmitter} emitter source
 * @param {String} event listen
 * @param {Function} fn callback
 * @return {object} object with a 'off' method to remove listener
 */

var once = ((emitter, event, evtId, fn) => {
  const listener = on(emitter, event, evt => {
    if (evt['evt-id'] === evtId) {
      listener.off();
      fn();
    }
  });
});

// import debug from 'debug'
// const logger = debug('rapid:main')

class Rapid {
  constructor(apiKey) {
    const url = base64.decode(apiKey);
    this.connection = new Connection(url);
    this.connected = false;
    this.connection.on('connected', state => {
      this.connected = state;
    });
  }

  collection(id) {
    checkId(id);
    return new Collection(this.connection, id);
  }

  channel(id) {
    checkId(id);
    return new Channel$1(this.connection, id);
  }

  authorize(authToken, callback) {
    const evtId = this.connection.authorize(authToken);

    if (callback) {
      const listeners = listen([on(this.connection, 'invalid-auth-token', err => {
        if (err['evt-id'] === evtId) {
          listeners.off();
          return callback(new InvalidAuthTokenError());
        }
      }), on(this.connection, 'ack', ack => {
        if (ack['evt-id'] === evtId) {
          listeners.off();
          return callback();
        }
      })]);
    }
  }

  deauthorize(callback) {
    const evtId = this.connection.deauthorize();
    if (callback) {
      once(this.connection, 'ack', evtId, callback);
    }
  }

  disconnect() {
    this.connection.close();
  }

  onConnectionStateChanged(callback) {
    this.connection.on('connected', state => callback(state));
  }
}

const cache = new Map();

const createClient = apiKey => {
  if (!apiKey) {
    throw new TypeError('Please provide a valid API key.');
  }

  const client = cache.get(apiKey);

  if (!client) {
    const newClient = new Rapid(apiKey);
    cache.set(apiKey, newClient);
    return newClient;
  }

  return client;
};

var index = { createClient, clients: cache };

module.exports = index;
